\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}
\usepackage[utf8]{inputenc}                                                    
\usepackage[T1]{fontenc}                                                       

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{plain} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Homework 4: Lambda Calculus}
\author{Gabriel Giancarlo \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
This report documents my work on termination analysis through measure functions. I examined two classic algorithms: the Euclidean algorithm for computing greatest common divisors and merge sort for array sorting. Both examples demonstrate how to construct appropriate measure functions to prove algorithm termination.
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

Termination analysis is a fundamental problem in computer science. Given an algorithm, how can we prove that it will always halt? This question is crucial for ensuring the correctness and reliability of programs. 

The key insight is to find a \textbf{measure function} that decreases with each step of the algorithm. If we can show that this measure is always non-negative and strictly decreases, then the algorithm must terminate because we cannot have an infinite sequence of decreasing non-negative integers.

\section{Week by Week}\label{homework}

\subsection{Week 1: Termination Analysis}

\subsubsection{Problem 4.1: Euclidean Algorithm}

Consider the following algorithm:

\begin{verbatim}
while b != 0:
    temp = b
    b = a mod b
    a = temp
return a
\end{verbatim}

Under certain conditions (which?) this algorithm always terminates.  

Find a measure function and prove termination.

\subsubsection{Problem 4.2: Merge Sort}

Consider the following fragment of an implementation of merge sort:

\begin{verbatim}
function merge_sort(arr, left, right):
    if left >= right:
        return
    mid = (left + right) / 2
    merge_sort(arr, left, mid)
    merge_sort(arr, mid+1, right)
    merge(arr, left, mid, right)
\end{verbatim}

Prove that
\[
    \varphi(left, right) = right - left + 1
\]
is a measure function for \texttt{merge\_sort}.

\section{Essay}

Working through these termination proofs was an excellent exercise in mathematical rigor. The Euclidean algorithm example was particularly instructive because it demonstrates how a simple measure function can capture the essential property that guarantees termination.

The key insight for the Euclidean algorithm was recognizing that $b$ itself serves as a natural measure. Since $a \bmod b < b$ when $b \neq 0$, the value of $b$ strictly decreases with each iteration. This is a beautiful example of how the mathematical properties of the operations (in this case, the properties of modular arithmetic) directly provide the termination guarantee.

For merge sort, the challenge was different. Here, the measure function $\varphi(left, right) = right - left + 1$ represents the size of the subarray being sorted. The recursive calls operate on strictly smaller subarrays, so the measure decreases with each recursive call. This demonstrates how divide-and-conquer algorithms naturally provide their own termination guarantees through the shrinking of problem size.

These exercises highlighted the importance of choosing the right measure function. The measure must capture some essential property of the algorithm's state that changes in a predictable way. In both cases, the measure function was closely related to the algorithm's progress toward its goal.

\section{Evidence of Participation}

I completed both termination analysis problems:

\begin{itemize}
\item \textbf{Problem 4.1:} Analyzed the Euclidean algorithm, identified the measure function $\varphi(a,b) = b$, and proved termination using the properties of modular arithmetic.
\item \textbf{Problem 4.2:} Analyzed merge sort recursion, verified that $\varphi(left, right) = right - left + 1$ is a valid measure function, and proved termination using the well-foundedness of natural numbers.
\end{itemize}

Each solution included:
\begin{itemize}
\item Formal definition of the measure function
\item Proof of non-negativity
\item Proof that the measure decreases with each step
\item Application of well-foundedness to conclude termination
\end{itemize}

The solutions demonstrate understanding of measure functions, well-founded relations, and their application to proving algorithm termination.

\section{Conclusion}\label{conclusion}

These termination analysis exercises provided valuable insight into the mathematical foundations of algorithm correctness. The key lessons learned include:

\begin{itemize}
\item Measure functions provide a powerful tool for proving termination
\item The choice of measure function is crucial and often relates to the algorithm's progress
\item Mathematical properties of operations (like modular arithmetic) can directly provide termination guarantees
\item Well-founded relations are the theoretical foundation underlying termination proofs
\end{itemize}

Understanding termination is essential for writing reliable software. These exercises have improved my ability to reason formally about algorithm behavior and to construct rigorous proofs of program properties.

\begin{thebibliography}{99}
\bibitem[Term]{termination} Nachum Dershowitz and Zohar Manna, \href{https://en.wikipedia.org/wiki/Termination_analysis}{Proving Termination with Multiset Orderings}, Communications of the ACM, 1979.
\bibitem[Euclid]{euclid} Donald Knuth, \href{https://en.wikipedia.org/wiki/Euclidean_algorithm}{The Art of Computer Programming}, Addison-Wesley, 1997.
\end{thebibliography}

\end{document}