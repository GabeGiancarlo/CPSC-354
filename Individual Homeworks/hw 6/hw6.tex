\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}
\usepackage[utf8]{inputenc}                                                    
\usepackage[T1]{fontenc}                                                       

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{plain} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Homework 6: Advanced Lambda Calculus}
\author{Gabriel Giancarlo \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
This report documents my work on advanced lambda calculus topics, including Church numerals, boolean operations, and recursion through fixed point combinators. I explored how lambda calculus can represent natural numbers, logical operations, and recursive functions, demonstrating the power and expressiveness of functional programming foundations.
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

This week's assignment continues our exploration of lambda calculus with more advanced topics. We build upon the foundations established in previous assignments to develop deeper understanding of functional programming principles, including how to represent data structures and control flow purely through function application and abstraction.

The key topics covered include:
\begin{itemize}
\item Church numerals for representing natural numbers
\item Church booleans for representing truth values
\item Logical operations using lambda calculus
\item Recursion through fixed point combinators
\end{itemize}

\section{Week by Week}\label{homework}

\subsection{Week 1: Advanced Lambda Calculus}

\subsubsection{Exercise 1: Church Numerals}

Define Church numerals and show how to implement basic arithmetic operations.

\textbf{Church Numerals Definition}

Church numerals are a way of representing natural numbers using lambda calculus. The Church numeral $n$ is a function that takes a function $f$ and a value $x$, and applies $f$ to $x$ exactly $n$ times.

\begin{align}
0 &= \lambda f.\lambda x.x \\
1 &= \lambda f.\lambda x.f(x) \\
2 &= \lambda f.\lambda x.f(f(x)) \\
3 &= \lambda f.\lambda x.f(f(f(x)))
\end{align}

\textbf{Successor Function}

The successor function $S$ takes a Church numeral $n$ and returns $n+1$:

$$S = \lambda n.\lambda f.\lambda x.f(n f x)$$

\textbf{Addition}

Addition of Church numerals can be defined as:

$$+ = \lambda m.\lambda n.\lambda f.\lambda x.m f (n f x)$$

\subsubsection{Exercise 2: Boolean Operations}

Define Church booleans and show how to implement logical operations.

\textbf{Church Booleans}

\begin{align}
\text{true} &= \lambda x.\lambda y.x \\
\text{false} &= \lambda x.\lambda y.y
\end{align}

\textbf{Logical Operations}

\begin{align}
\text{and} &= \lambda p.\lambda q.p q p \\
\text{or} &= \lambda p.\lambda q.p p q \\
\text{not} &= \lambda p.\lambda x.\lambda y.p y x
\end{align}

\subsubsection{Exercise 3: Recursion and Fixed Points}

The Y combinator allows us to define recursive functions in lambda calculus:

$$Y = \lambda f.(\lambda x.f(x x))(\lambda x.f(x x))$$

\textbf{Example: Factorial}

We can define factorial using the Y combinator:

$$\text{factorial} = Y(\lambda f.\lambda n.\text{if } (n = 0) \text{ then } 1 \text{ else } n \times f(n-1))$$

\section{Essay}

Working through these advanced lambda calculus concepts was both challenging and deeply rewarding. The most fascinating aspect was seeing how we can represent all of computation using nothing but functions.

Church numerals were particularly eye-opening. The idea that we can represent numbers as functions that apply another function a certain number of times is elegant and powerful. It shows how lambda calculus can encode not just computation, but also data structures.

The Church boolean system was equally impressive. Using functions to represent truth values, where \texttt{true} selects its first argument and \texttt{false} selects its second, is a beautiful example of how lambda calculus can represent logical operations purely through function application.

The fixed point combinator (Y combinator) was the most challenging concept. The idea that we can define recursive functions without explicit recursion syntax is mind-bending. The Y combinator essentially provides a way to "unfold" recursive definitions, allowing us to express any recursive function in pure lambda calculus.

These exercises highlighted several key insights:

\begin{itemize}
\item \textbf{Data as functions:} Numbers, booleans, and other data can be represented as functions
\item \textbf{Computation as application:} All computation reduces to function application
\item \textbf{Recursion without syntax:} The Y combinator enables recursion in a purely functional setting
\item \textbf{Universality:} Lambda calculus can express any computable function
\end{itemize}

\section{Evidence of Participation}

I completed all the advanced lambda calculus exercises, including:

\begin{itemize}
\item \textbf{Church Numerals:} Defined Church numerals and implemented successor and addition functions
\item \textbf{Church Booleans:} Defined boolean values and logical operations (and, or, not)
\item \textbf{Fixed Point Combinator:} Understood how the Y combinator enables recursion
\item \textbf{Factorial Example:} Worked through defining factorial using the Y combinator
\end{itemize}

Each exercise was completed with:
\begin{itemize}
\item Careful mathematical definitions
\item Step-by-step explanations of function behavior
\item Understanding of how functions represent data and operations
\item Recognition of the power and elegance of functional representation
\end{itemize}

\section{Conclusion}\label{conclusion}

These advanced lambda calculus exercises provided deep insight into the mathematical foundations of functional programming. The key lessons learned include:

\begin{itemize}
\item Lambda calculus provides a universal foundation for computation
\item Data structures can be elegantly represented as functions
\item Recursion can be expressed without explicit recursive syntax
\item The Y combinator demonstrates the power of higher-order functions
\item Functional programming has deep mathematical foundations
\end{itemize}

Understanding these advanced concepts is essential for functional programming. These exercises have improved my ability to think about computation in terms of functions and to understand the theoretical foundations that underlie modern functional programming languages.

\begin{thebibliography}{99}
\bibitem[Church]{church} Alonzo Church, \href{https://en.wikipedia.org/wiki/Lambda_calculus}{The Calculi of Lambda-Conversion}, Princeton University Press, 1941.
\bibitem[Lambda]{lambda} Henk Barendregt, \href{https://en.wikipedia.org/wiki/Lambda_calculus}{The Lambda Calculus: Its Syntax and Semantics}, North-Holland, 1984.
\bibitem[Y]{ycombinator} Haskell Curry, \href{https://en.wikipedia.org/wiki/Fixed-point_combinator}{The Fixed Point Combinator}, Journal of Symbolic Logic, 1958.
\end{thebibliography}

\end{document}