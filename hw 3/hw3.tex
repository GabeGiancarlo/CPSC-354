\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}
\usepackage[utf8]{inputenc}                                                    
\usepackage[T1]{fontenc}                                                       

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{plain} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{String Rewriting Exercises}
\author{Gabriel Giancarlo \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
This assignment explores abstract reduction systems (ARS) through string rewriting exercises. We analyze various rewrite rules to understand termination, confluence, and the use of invariants to characterize equivalence classes. The exercises demonstrate how seemingly simple string transformations can implement complex algorithms.
\end{abstract}

\section{Introduction}

\textit{Term Rewriting} refers to rewriting abstract syntax trees (typically without binders). 
\textit{String Rewriting} is the special case where we only rewrite strings (as opposed to trees). 
Normal forms, confluence, termination, invariants can all be studied in this simpler setting. 
Everything we will learn will also transfer to the generalisations of string rewriting. 
(And, btw, string rewriting is already Turing complete (Why?).)

\bigskip

In all of the following exercises the task is to analyse a so-called \textit{abstract reduction system} (ARS). 
An ARS $(A,\to)$ consists of a set $A$ of words (finite lists, strings) and $\to$ is a relation on $A$. 
When we specify a rewrite rule
\[
w \to v
\]
we understand that it can be applied inside any longer word. 
For example, the rewrite rule
\[
ba \to ab
\]
can be applied to rewrite the word $cbad$ to $cabd$.

\bigskip

\noindent\textbf{Footnote.} 
The math behind the exercises requires the material on equivalence relations, abstract reduction systems, termination and invariants, but it may be good to first try the exercises and then learn the math.

\bigskip

The exercises in this section come in form of puzzles. 
Think of each ARS as the \textbf{implementation of an algorithm}. 
The puzzle for you is to find out the \textbf{input-output behaviour} of the algorithm, that is, you have to find out what the algorithm is meant to compute. 
In each case, the task is to explain without mentioning the rules what specification the algorithm/ARS implements.

\medskip

\textbf{Definition.} 
An \textbf{abstract characterization} or a \textbf{specification} of an ARS is a description of its input/output behaviour that does not refer to the rules of the ARS (the implementation). 

\section{The Task}

Roughly speaking, the task is as follows:

\begin{itemize}
    \item Show that the ARS is an algorithm (that is, the ARS is terminating and every input computes to a unique result $=$ the ARS has unique normal forms).
    \item Find the specification the ARS implements. This usually requires describing the equality (equivalence relation) generated by the rewrite relation independently of the rewrite relation itself by an invariant.
\end{itemize}

\section{The Roadmap}

\textit{(Skip this at first reading.)}

Here is a roadmap that you may find useful:

\begin{itemize}
    \item The basic question is how many equivalence classes there are and how we can recognise in which equivalence class a given word is.
    \item Collect basic facts and observations. Are there normal forms? What are they? Do all elements reduce to a normal form? Are normal forms unique?
    \item Does the system terminate?
    \item Can we characterise equivalence classes by unique normal forms?
    \item Can we characterise equivalence classes by invariants?
    \item Derive a specification from the invariant.
\end{itemize}

\section{Exercises (The Method)}

The purpose of these exercises is not so much to practice problem solving but rather to learn the method of decidability via rewriting to normal form and the method of invariants. 
In particular, the relationship between $\longrightarrow$ and $\stackrel{\ast}{\longleftrightarrow}$ is important here.

\section{Exercise 1}

The rewrite rule is:

\[
    ba \to ab
\]

\subsection{Why does the ARS terminate?}
The system always terminates because every time we apply the rule, the letters get closer to being in the correct order. There are only a limited number of ways to reorder a finite string, so eventually no more rules can be applied.

\subsection{What is the result of a computation (the normal form)?}
The normal form is the string where all the \texttt{a}'s come before all the \texttt{b}'s. For example, starting with \texttt{baba} we eventually reach \texttt{aabb}.

\subsection{Show that the result is unique (the ARS is confluent).}
Yes, the result is unique. No matter how we choose to apply the rule, we always end up with the same final string: all the \texttt{a}'s on the left and all the \texttt{b}'s on the right. This shows the system is confluent.

\subsection{What specification does this algorithm implement?}
This algorithm basically sorts the string by moving all the \texttt{a}'s to the left and the \texttt{b}'s to the right. In other words, it implements a simple sorting process.

\section{Exercise 2}

The rewrite rules are:
\[
\texttt{aa} \to \texttt{a},\qquad
\texttt{bb} \to \texttt{a},\qquad
\texttt{ab} \to \texttt{b},\qquad
\texttt{ba} \to \texttt{b}.
\]

\begin{enumerate}[label=(\alph*)]
  \item \textbf{Why does the ARS terminate?}
  
  Every rule replaces two adjacent letters by a single letter, so each rewrite step strictly decreases the length of the word by exactly $1$. Since words are finite, you can't keep shortening forever. Therefore every rewrite sequence must stop after finitely many steps, so the ARS terminates.
  
  \item \textbf{What are the normal forms?}
  
  Because each step reduces length by $1$, any normal form must be a word that cannot be shortened further. The only words of length $1$ are \texttt{a} and \texttt{b}, and they contain no length-$2$ substring to rewrite, so they are normal. There are no other normal forms (every word of length $\ge 2$ has some adjacent pair and so admits a rewrite), hence the normal forms are exactly
  \[
    \texttt{a}\quad\text{and}\quad\texttt{b}.
  \]
  
  \item \textbf{Is there a string \(s\) that reduces to both \texttt{a} and \texttt{b}?}
  
  No. Intuitively, the rules preserve whether the number of \texttt{b}'s is even or odd (see part (d)), and \texttt{a} has zero \texttt{b}'s (even) while \texttt{b} has one \texttt{b} (odd). So a given input cannot end up as both \texttt{a} and \texttt{b}. Concretely: since the system terminates and every input has at least one normal form, and because an invariant (parity of \#\texttt{b}'s) distinguishes \texttt{a} from \texttt{b}, no string can reduce to both.
  
  \item \textbf{Show that the ARS is confluent.}
  
  We use the invariant ``number of \texttt{b}'s modulo $2$'' to argue confluence together with termination.
  
  \begin{itemize}
    \item Check the invariant: each rule changes the string locally but does not change the parity of the number of \texttt{b}'s.
      \begin{itemize}
        \item $\texttt{aa}\to\texttt{a}$: number of \texttt{b}'s unchanged (both sides have 0 \texttt{b}'s).
        \item $\texttt{bb}\to\texttt{a}$: two \texttt{b}'s are removed, so \#\texttt{b} decreases by $2$ (parity unchanged).
        \item $\texttt{ab}\to\texttt{b}$ and $\texttt{ba}\to\texttt{b}$: before there is exactly one \texttt{b}, after there is one \texttt{b} (parity unchanged).
      \end{itemize}
    \item By termination, every word rewrites in finitely many steps to some normal form (either \texttt{a} or \texttt{b}). Because parity of \#\texttt{b} is invariant, a word with even \#\texttt{b} cannot reach \texttt{b} (which has odd \#\texttt{b}) and a word with odd \#\texttt{b} cannot reach \texttt{a}. So each input has exactly one possible normal form determined by that parity.
  \end{itemize}
  
  Termination plus the fact that every input has a unique normal form implies confluence (there can't be two different normal forms reachable from the same input). So the ARS is confluent.
  
  \item \textbf{Which words become equal if we replace `$\to$' by `$=$`?}
  
  If we let `$=$` be the equivalence relation generated by the rewrite rules, then two words are equivalent exactly when they have the same parity of \texttt{b}'s. In other words:
  \[
    u = v \quad\Longleftrightarrow\quad |u|_{\texttt{b}} \equiv |v|_{\texttt{b}} \pmod{2}.
  \]
  So there are exactly two equivalence classes: the class of words with an even number of \texttt{b}'s (these are all equivalent to \texttt{a}) and the class of words with an odd number of \texttt{b}'s (these are all equivalent to \texttt{b}).
  
  \item \textbf{Characterise the equality abstractly / using modular arithmetic / final specification.}
  
  An abstract (implementation-free) description is: the system computes the parity of the number of \texttt{b}'s in the input word. If the number of \texttt{b}'s is even, the output is \texttt{a}; if it is odd, the output is \texttt{b}.
  
  A modular-arithmetic formulation: identify \texttt{a} with $0$ and \texttt{b} with $1$. For a word $w=w_1\cdots w_n$ set
  \[
    F(w)\;=\;\sum_{i=1}^n \mathbf{1}_{\{w_i=\texttt{b}\}}\ \pmod{2}.
  \]
  Then the normal form is \texttt{a} when $F(w)=0$ and \texttt{b} when $F(w)=1$.
  
  \textbf{Specification:} the algorithm takes a word over $\{\texttt{a},\texttt{b}\}$ and returns a single letter that tells you the parity of the number of \texttt{b}'s: \texttt{a} for even parity, \texttt{b} for odd parity. Equivalently, it computes the XOR (parity) of the letters when \texttt{a}=0 and \texttt{b}=1.
\end{enumerate}

\bigskip

\textbf{Example (work shown).} Start with \texttt{baba} (it has two \texttt{b}'s, so parity is even, we expect \texttt{a}):
\[
\texttt{baba} \xrightarrow{\ \texttt{ba}\to\texttt{b}\ } \texttt{bba}
\quad\xrightarrow{\ \texttt{bb}\to\texttt{a}\ } \texttt{aa}
\quad\xrightarrow{\ \texttt{aa}\to\texttt{a}\ } \texttt{a}.
\]
No matter which valid rewrites we choose at each step, we end up with \texttt{a}; that matches the parity-based specification above.

\section{Exercise 5}

The rewrite rules are
\[
\texttt{ab}\longrightarrow\texttt{ba},\qquad
\texttt{ba}\longrightarrow\texttt{ab},\qquad
\texttt{aa}\longrightarrow\varepsilon,\qquad
\texttt{b}\longrightarrow\varepsilon.
\]

I will answer each bullet carefully and give short, clear justifications.

\medskip

\textbf{(i) Some sample reductions.}

\begin{itemize}
  \item Start with \(\texttt{abba}\).
  \[
    \texttt{abba}\xrightarrow{\ \texttt{b}\to\varepsilon\ } \texttt{aba}
    \xrightarrow{\ \texttt{ba}\to\texttt{ab}\ } \texttt{aab}
    \xrightarrow{\ \texttt{aa}\to\varepsilon\ } \texttt{b}
    \xrightarrow{\ \texttt{b}\to\varepsilon\ }\varepsilon.
  \]
  So \(\texttt{abba}\to^{*}\varepsilon\).
  \item Start with \(\texttt{bababa}\).
  \[
    \texttt{bababa}\xrightarrow{\ \texttt{b}\to\varepsilon\ } \texttt{ababa}
    \xrightarrow{\ \texttt{b}\to\varepsilon\ } \texttt{aaba}
    \xrightarrow{\ \texttt{aa}\to\varepsilon\ } \texttt{ba}
    \xrightarrow{\ \texttt{b}\to\varepsilon\ } \texttt{a}.
  \]
  So \(\texttt{bababa}\to^{*}\texttt{a}\).
\end{itemize}

(These choices of rewrite steps are not unique; other valid choices lead to the same equivalence-class representatives — see the invariant-based description below.)

\bigskip

\textbf{(ii) Why is the ARS not terminating?}

Because of the two swap rules \(\texttt{ab}\to\texttt{ba}\) and \(\texttt{ba}\to\texttt{ab}\), you can cycle forever on any alternating adjacent pair. The shortest example is \(\texttt{ab}\):
\[
\texttt{ab}\longrightarrow\texttt{ba}\longrightarrow\texttt{ab}\longrightarrow\cdots
\]
This gives an infinite rewrite sequence, so the system is not terminating. (The erasing rules exist, but they don't prevent the existence of infinite swapping sequences when you choose only swaps.)

\bigskip

\textbf{(iii) Find two strings that are not equivalent. How many non-equivalent strings can you find?}

A simple pair of non-equivalent strings is
\[
\texttt{a}\quad\text{and}\quad\varepsilon.
\]
They are not equivalent because no rule can turn \(\texttt{a}\) into \(\varepsilon\): the only erasing rules are \(\texttt{aa}\to\varepsilon\) (needs two \texttt{a}'s) and \(\texttt{b}\to\varepsilon\) (erases \texttt{b}'s). In particular, the parity of the number of \texttt{a}'s (even vs odd) cannot be changed by any step, so a single \texttt{a} (odd number of \texttt{a}'s) cannot become \(\varepsilon\) (zero \texttt{a}'s, even).

How many non-equivalent strings can we find? If we ask for \emph{pairwise non-equivalent} representatives, the ARS only distinguishes two equivalence classes (see next part). So up to equivalence there are only two distinct outcomes: one represented by \(\varepsilon\) and one represented by \(\texttt{a}\). Of course there are infinitely many distinct strings as concrete syntactic objects, but they fall into just two equivalence classes.

\bigskip

\textbf{(iv) How many equivalence classes does \(\stackrel{*}{\longleftrightarrow}\) have? Describe them; what are the normal forms?}

\emph{Invariant.} Swaps \(\texttt{ab}\leftrightarrow\texttt{ba}\) never change the counts of \texttt{a}'s or \texttt{b}'s. The rules \(\texttt{aa}\to\varepsilon\) removes two \texttt{a}'s, and \(\texttt{b}\to\varepsilon\) removes one \texttt{b}. Therefore the \emph{parity} of the number of \texttt{a}'s,
\[
|w|_{\texttt{a}}\pmod{2},
\]
is preserved by every rule. (Each step either removes 0, 2, or an even number of \texttt{a}'s.) So parity of \texttt{a}'s is an invariant.

\emph{Completeness / reachability to representatives.} Using swaps we can reorder letters arbitrarily (because the two-way swaps generate all permutations of positions), so we can gather all \texttt{a}'s together. Then repeatedly apply \(\texttt{aa}\to\varepsilon\) to cancel \texttt{a}'s in pairs; use \(\texttt{b}\to\varepsilon\) to erase any \texttt{b}'s. After these reductions every string is reduced to either
\[
\varepsilon \quad\text{(if the original had an even number of \texttt{a}'s),}
\qquad\text{or}\qquad
\texttt{a} \quad\text{(if the original had an odd number of \texttt{a}'s).}
\]
So there are exactly two equivalence classes, determined by the parity of \(\#\texttt{a}\). The two normal forms (irreducible representatives) are \(\varepsilon\) and \(\texttt{a}\). (They are irreducible since none of the four left-hand sides occurs in them.)

Thus \(\stackrel{*}{\longleftrightarrow}\) partitions all strings into two classes:
\[
\{w\mid |w|_{\texttt{a}}\text{ is even}\}\quad\text{and}\quad\{w\mid |w|_{\texttt{a}}\text{ is odd}\},
\]
with canonical normal forms \(\varepsilon\) and \(\texttt{a}\) respectively.

\bigskip

\textbf{(v) Can you modify the ARS so that it becomes terminating without changing its equivalence classes?}

Yes. A standard trick is to orient the swapping in one direction only (so swaps become a ``sorting'' operation) while keeping the erasing rules. For instance, replace the two-way swaps by a single directed rule
\[
\texttt{ba}\longrightarrow\texttt{ab}
\]
(only move \texttt{a}'s left). Keep \(\texttt{aa}\to\varepsilon\) and \(\texttt{b}\to\varepsilon\). Call this the modified ARS.

Why this preserves equivalence classes: the reflexive–symmetric–transitive closure of the original two-way swaps is the same as the closure generated by the one-way swap once you allow symmetric closure (permutations). In other words, the original equivalence relation said "letters can be permuted arbitrarily" — orienting swaps only gives a terminating presentation (a canonical way to permute) but does not change the equivalence relation when you take the equivalence closure.

Why the modified system terminates: use the pair
\[
\big(\mathrm{inv}(w),\ |w|\big)
\]
ordered lexicographically, where
\[
\mathrm{inv}(w)=\#\{(i<j)\mid w_i=\texttt{b},\ w_j=\texttt{a}\}
\]
is the number of ``inversions'' (a \texttt{b} before an \texttt{a}). Check each rule:

\begin{itemize}
  \item \(\texttt{ba}\to\texttt{ab}\) strictly decreases \(\mathrm{inv}(w)\) by at least \(1\), length unchanged.
  \item \(\texttt{aa}\to\varepsilon\) strictly decreases \(|w|\) (by \(2\)), while \(\mathrm{inv}(w)\) stays the same (there are no \texttt{b}'s involved in that pair).
  \item \(\texttt{b}\to\varepsilon\) strictly decreases \(|w|\) (by \(1\)), \(\mathrm{inv}(w)\) may decrease but at worst stays the same.
\end{itemize}

So every rewrite step strictly decreases the lexicographically ordered pair \((\mathrm{inv},|w|)\), which is a well-founded order on finite strings. Thus there are no infinite rewrite sequences in the modified system, i.e.\ it terminates. Because the reachable normal forms under the modified system are still exactly \(\varepsilon\) and \(\texttt{a}\), the equivalence classes are unchanged.

\bigskip

\textbf{(vi) A couple of natural questions about strings (a specification) that this ARS answers.}

Think of the ARS as an algorithm that reduces a given input string to a canonical representative. Two natural questions (specifications) that are decided by this ARS are:

\begin{enumerate}
  \item \emph{Does the input string have an even number of \texttt{a}'s?}  
  The ARS reduces the input to \(\varepsilon\) iff the answer is "yes".
  \item \emph{Does the input string have an odd number of \texttt{a}'s?}  
  The ARS reduces the input to \(\texttt{a}\) iff the answer is "yes".
\end{enumerate}

These are good specifications because they are complete invariants: the parity of \(\#\texttt{a}\) completely characterizes the equivalence class of any string (independent of the rewrite rules).

\bigskip

\textbf{Remark / answer to Exse 5b (change \(\texttt{aa}\to\varepsilon\) into \(\texttt{aa}\to\texttt{a}\)).}

Replace the rule \(\texttt{aa}\to\varepsilon\) by \(\texttt{aa}\to\texttt{a}\) and keep the rest. Then:

\begin{itemize}
  \item Any positive number of \texttt{a}'s collapses to a single \texttt{a} (repeatedly use \(\texttt{aa}\to\texttt{a}\)). All \texttt{b}'s still erase by \(\texttt{b}\to\varepsilon\).
  \item The relevant invariant is no longer parity; instead the invariant that classifies strings is whether the string contains at least one \texttt{a} or not.
  \item Therefore the equivalence classes become:
    \[
      \{w\mid |w|_{\texttt{a}}=0\}\quad\text{(all these are equivalent to }\varepsilon\text{),}
      \qquad
      \{w\mid |w|_{\texttt{a}}\ge 1\}\quad\text{(all equivalent to }\texttt{a}\text{).}
    \]
  \item Orienting swaps as above (say \(\texttt{ba}\to\texttt{ab}\)) again gives a terminating presentation with the same classes; a suitable measure is the same lexicographic pair \((\mathrm{inv}(w),|w|)\) or simply \((\mathrm{inv}(w),\#\texttt{a}>0,\ |w|)\) where the boolean \(\#\texttt{a}>0\) is treated in the order before \(|w|\).
\end{itemize}

So Exse 5b is similar in spirit but the invariant that captures meaning changes from ``parity of \texttt{a}'' to ``presence of at least one \texttt{a}''.

\bigskip

\textbf{Final short summary .}
\begin{itemize}
  \item The original system is not terminating because swaps can cycle.
  \item There are exactly two equivalence classes: words with an even number of \texttt{a}'s (class represented by \(\varepsilon\)) and words with an odd number of \texttt{a}'s (class represented by \(\texttt{a}\)).
  \item A terminating presentation that preserves the same equivalence relation is obtained by orienting swaps (e.g.\ \(\texttt{ba}\to\texttt{ab}\)) and using the measure \((\mathrm{inv}(w),|w|)\) to prove termination.
  \item The ARS answers a clear question: ``Is the number of \texttt{a}'s even or odd?'' (or in Exse 5b: ``Does the string contain any \texttt{a}'s at all?'').
\end{itemize}

\section{Exercise 7}

Consider the rewrite rules

        ab -> a
        bb -> b
        aa -> b
        
plus rules saying that the order of letters does not matter. 

- Think of `a` and `b` as colours and an [urn](https://en.wikipedia.org/wiki/Urn_problem) that has balls of colour `a` ("white") and `b` ("black"). Interpret the rewrite rules as rules about drawing balls from the urn.
- If you start with 198 black balls and 99 white balls, what is the colour of the last ball remaining? 
- Answer the question above with the help of a suitable invariant.
- Use the invariant to show that the system has unique normal forms.
- If you start with $n$ black balls and $m$ white balls, what is the colour of the last ball remaining?

\section{Exercise 8}

The rewrite rules are
\[
\texttt{ab}\to\texttt{cc},\qquad
\texttt{ac}\to\texttt{bb},\qquad
\texttt{bc}\to\texttt{aa},
\]
and we are allowed to permute letters (order doesn't matter), so we can think of configurations just as multisets or triples of counts \((a,b,c)\).  
Start: \((a,b,c)=(15,14,13)\). Total letters \(N=42\) is preserved by every step (each rule consumes two letters and produces two), so any reachable configuration must still sum to \(42\).

We want to know whether we can reach a configuration that has only one kind of letter, i.e.\ \((42,0,0)\), \((0,42,0)\) or \((0,0,42)\).

\bigskip

\textbf{Key invariant )}  
Look at the difference \(a-b\) modulo \(3\). Check how this changes under each rule:

\begin{itemize}
  \item For \(\texttt{ab}\to\texttt{cc}\): \((a,b,c)\) goes to \((a-1,b-1,c+2)\). So
  \[
  (a-1)-(b-1)=a-b,
  \]
  i.e.\ \(a-b\) does not change at all.
  \item For \(\texttt{ac}\to\texttt{bb}\): \((a,b,c)\mapsto(a-1,b+2,c-1)\). So
  \[
  (a-1)-(b+2)=a-b-3,
  \]
  i.e.\ \(a-b\) changes by \(-3\).
  \item For \(\texttt{bc}\to\texttt{aa}\): \((a,b,c)\mapsto(a+2,b-1,c-1)\). So
  \[
  (a+2)-(b-1)=a-b+3,
  \]
  i.e.\ \(a-b\) changes by \(+3\).
\end{itemize}

So every rule changes \(a-b\) by a multiple of \(3\). That means the value of \(a-b\) modulo \(3\) is an invariant of the system.

\bigskip

\textbf{Apply the invariant to the start and targets.}  
Compute the invariant for the start:
\[
a-b = 15-14 = 1 \equiv 1 \pmod{3}.
\]
For the three all-one-letter targets we have
\[
(42,0,0):\ a-b=42\equiv 0\pmod{3},\quad
(0,42,0):\ a-b=-42\equiv 0\pmod{3},\quad
(0,0,42):\ a-b=0\equiv 0\pmod{3}.
\]
Every all-one-letter configuration has \(a-b\equiv 0\pmod{3}\), but our start has \(a-b\equiv 1\pmod{3}\). Since \(a-b\pmod{3}\) is invariant, it is impossible to reach any of the all-one-letter targets from \((15,14,13)\).

\bigskip

\textbf{Conclusion.}  
No — starting from \(15\) \texttt{a}'s, \(14\) \texttt{b}'s and \(13\) \texttt{c}'s you \emph{cannot} reach a configuration with only \texttt{a}'s, only \texttt{b}'s, or only \texttt{c}'s. The invariant \(a-b\pmod{3}\) (which equals \(1\) at the start) rules those targets out (they all have value \(0\) modulo \(3\)).

\end{document}