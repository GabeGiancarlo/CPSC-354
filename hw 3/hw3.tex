\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}
\usepackage[utf8]{inputenc}                                                    
\usepackage[T1]{fontenc}                                                       

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{plain} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Report}
\author{Gabriel Giancarlo \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
This report documents my work on string rewriting exercises, exploring abstract reduction systems (ARS) and their properties. Through various string transformation exercises, I learned about termination, confluence, and the use of invariants to characterize equivalence classes.
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

\textit{Term Rewriting} refers to rewriting abstract syntax trees (typically without binders). 
\textit{String Rewriting} is the special case where we only rewrite strings (as opposed to trees). 
Normal forms, confluence, termination, invariants can all be studied in this simpler setting. 
Everything we will learn will also transfer to the generalisations of string rewriting. 
(And, btw, string rewriting is already Turing complete (Why?).)

\bigskip

In all of the following exercises the task is to analyse a so-called \textit{abstract reduction system} (ARS). 
An ARS $(A,\to)$ consists of a set $A$ of words (finite lists, strings) and $\to$ is a relation on $A$. 
When we specify a rewrite rule
\[
w \to v
\]
we understand that it can be applied inside any longer word. 
For example, the rewrite rule
\[
ba \to ab
\]
can be applied to rewrite the word $cbad$ to $cabd$.

\bigskip

\noindent\textbf{Footnote.} 
The math behind the exercises requires the material on equivalence relations, abstract reduction systems, termination and invariants, but it may be good to first try the exercises and then learn the math.

\bigskip

The exercises in this section come in form of puzzles. 
Think of each ARS as the \textbf{implementation of an algorithm}. 
The puzzle for you is to find out the \textbf{input-output behaviour} of the algorithm, that is, you have to find out what the algorithm is meant to compute. 
In each case, the task is to explain without mentioning the rules what specification the algorithm/ARS implements.

\medskip

\textbf{Definition.} 
An \textbf{abstract characterization} or a \textbf{specification} of an ARS is a description of its input/output behaviour that does not refer to the rules of the ARS (the implementation). 

\section{Week by Week}\label{homework}

\subsection{Week 1: String Rewriting Systems}

The task is as follows:

\begin{itemize}
    \item Show that the ARS is an algorithm (that is, the ARS is terminating and every input computes to a unique result $=$ the ARS has unique normal forms).
    \item Find the specification the ARS implements. This usually requires describing the equality (equivalence relation) generated by the rewrite relation independently of the rewrite relation itself by an invariant.
\end{itemize}

\subsubsection{Exercise 1: Basic Sorting}

The rewrite rule is:

\[
    ba \to ab
\]

\textbf{Why does the ARS terminate?}
The system always terminates because every time we apply the rule, the letters get closer to being in the correct order. There are only a limited number of ways to reorder a finite string, so eventually no more rules can be applied.

\textbf{What is the result of a computation (the normal form)?}
The normal form is the string where all the \texttt{a}'s come before all the \texttt{b}'s. For example, starting with \texttt{baba} we eventually reach \texttt{aabb}.

\textbf{Show that the result is unique (the ARS is confluent).}
Yes, the result is unique. No matter how we choose to apply the rule, we always end up with the same final string: all the \texttt{a}'s on the left and all the \texttt{b}'s on the right. This shows the system is confluent.

\textbf{What specification does this algorithm implement?}
This algorithm basically sorts the string by moving all the \texttt{a}'s to the left and the \texttt{b}'s to the right. In other words, it implements a simple sorting process.

\subsubsection{Exercise 2: Parity Computation}

The rewrite rules are:
\[
\texttt{aa} \to \texttt{a},\qquad
\texttt{bb} \to \texttt{a},\qquad
\texttt{ab} \to \texttt{b},\qquad
\texttt{ba} \to \texttt{b}.
\]

\begin{enumerate}[label=(\alph*)]
  \item \textbf{Why does the ARS terminate?}
  
  Every rule replaces two adjacent letters by a single letter, so each rewrite step strictly decreases the length of the word by exactly $1$. Since words are finite, you can't keep shortening forever. Therefore every rewrite sequence must stop after finitely many steps, so the ARS terminates.
  
  \item \textbf{What are the normal forms?}
  
  Because each step reduces length by $1$, any normal form must be a word that cannot be shortened further. The only words of length $1$ are \texttt{a} and \texttt{b}, and they contain no length-$2$ substring to rewrite, so they are normal. There are no other normal forms (every word of length $\ge 2$ has some adjacent pair and so admits a rewrite), hence the normal forms are exactly
  \[
    \texttt{a}\quad\text{and}\quad\texttt{b}.
  \]
  
  \item \textbf{Is there a string \(s\) that reduces to both \texttt{a} and \texttt{b}?}
  
  No. Intuitively, the rules preserve whether the number of \texttt{b}'s is even or odd (see part (d)), and \texttt{a} has zero \texttt{b}'s (even) while \texttt{b} has one \texttt{b} (odd). So a given input cannot end up as both \texttt{a} and \texttt{b}. Concretely: since the system terminates and every input has at least one normal form, and because an invariant (parity of \#\texttt{b}'s) distinguishes \texttt{a} from \texttt{b}, no string can reduce to both.
  
  \item \textbf{Show that the ARS is confluent.}
  
  We use the invariant ``number of \texttt{b}'s modulo $2$'' to argue confluence together with termination.
  
  \begin{itemize}
    \item Check the invariant: each rule changes the string locally but does not change the parity of the number of \texttt{b}'s.
      \begin{itemize}
        \item $\texttt{aa}\to\texttt{a}$: number of \texttt{b}'s unchanged (both sides have 0 \texttt{b}'s).
        \item $\texttt{bb}\to\texttt{a}$: two \texttt{b}'s are removed, so \#\texttt{b} decreases by $2$ (parity unchanged).
        \item $\texttt{ab}\to\texttt{b}$ and $\texttt{ba}\to\texttt{b}$: before there is exactly one \texttt{b}, after there is one \texttt{b} (parity unchanged).
      \end{itemize}
    \item By termination, every word rewrites in finitely many steps to some normal form (either \texttt{a} or \texttt{b}). Because parity of \#\texttt{b} is invariant, a word with even \#\texttt{b} cannot reach \texttt{b} (which has odd \#\texttt{b}) and a word with odd \#\texttt{b} cannot reach \texttt{a}. So each input has exactly one possible normal form determined by that parity.
  \end{itemize}
  
  Termination plus the fact that every input has a unique normal form implies confluence (there can't be two different normal forms reachable from the same input). So the ARS is confluent.
  
  \item \textbf{Which words become equal if we replace `$\to$' by `$=$`?}
  
  If we let `$=$` be the equivalence relation generated by the rewrite rules, then two words are equivalent exactly when they have the same parity of \texttt{b}'s. In other words:
  \[
    u = v \quad\Longleftrightarrow\quad |u|_{\texttt{b}} \equiv |v|_{\texttt{b}} \pmod{2}.
  \]
  So there are exactly two equivalence classes: the class of words with an even number of \texttt{b}'s (these are all equivalent to \texttt{a}) and the class of words with an odd number of \texttt{b}'s (these are all equivalent to \texttt{b}).
  
  \item \textbf{Characterise the equality abstractly / using modular arithmetic / final specification.}
  
  An abstract (implementation-free) description is: the system computes the parity of the number of \texttt{b}'s in the input word. If the number of \texttt{b}'s is even, the output is \texttt{a}; if it is odd, the output is \texttt{b}.
  
  A modular-arithmetic formulation: identify \texttt{a} with $0$ and \texttt{b} with $1$. For a word $w=w_1\cdots w_n$ set
  \[
    F(w)\;=\;\sum_{i=1}^n \mathbf{1}_{\{w_i=\texttt{b}\}}\ \pmod{2}.
  \]
  Then the normal form is \texttt{a} when $F(w)=0$ and \texttt{b} when $F(w)=1$.
  
  \textbf{Specification:} the algorithm takes a word over $\{\texttt{a},\texttt{b}\}$ and returns a single letter that tells you the parity of the number of \texttt{b}'s: \texttt{a} for even parity, \texttt{b} for odd parity. Equivalently, it computes the XOR (parity) of the letters when \texttt{a}=0 and \texttt{b}=1.
\end{enumerate}

\bigskip

\textbf{Example (work shown).} Start with \texttt{baba} (it has two \texttt{b}'s, so parity is even, we expect \texttt{a}):
\[
\texttt{baba} \xrightarrow{\ \texttt{ba}\to\texttt{b}\ } \texttt{bba}
\quad\xrightarrow{\ \texttt{bb}\to\texttt{a}\ } \texttt{aa}
\quad\xrightarrow{\ \texttt{aa}\to\texttt{a}\ } \texttt{a}.
\]
No matter which valid rewrites we choose at each step, we end up with \texttt{a}; that matches the parity-based specification above.

\section{Essay}

Working through these string rewriting exercises was both challenging and enlightening. The most fascinating aspect was discovering how seemingly simple string transformation rules can implement complex algorithms. 

The key insight that emerged was the power of invariants. In Exercise 2, realizing that the parity of the number of \texttt{b}'s was preserved by all rewrite rules was the breakthrough that made everything else fall into place. This showed me how mathematical properties can be used to prove correctness and understand the behavior of algorithms without having to trace through every possible execution path.

The concept of confluence was particularly interesting. The idea that different sequences of rewrite steps can lead to the same final result demonstrates the robustness of these systems. It's reassuring to know that the order of operations doesn't affect the final outcome, which is crucial for parallel and distributed computing.

These exercises also highlighted the connection between formal systems and practical algorithms. The string rewriting systems we studied are essentially abstract machines that compute specific functions. Understanding this connection helps bridge the gap between theoretical computer science and practical programming.

\section{Evidence of Participation}

I completed all the string rewriting exercises, including:

\begin{itemize}
\item Exercise 1: Analysis of the sorting algorithm with rule $ba \to ab$
\item Exercise 2: Complete analysis of the parity computation system with four rewrite rules
\item Detailed proofs of termination, confluence, and invariant properties
\item Mathematical characterization of equivalence classes using modular arithmetic
\item Worked examples showing the reduction process step-by-step
\end{itemize}

Each exercise was solved with careful mathematical reasoning, including formal proofs where appropriate. The solutions demonstrate understanding of abstract reduction systems, termination analysis, and the use of invariants to characterize algorithm behavior.

\section{Conclusion}\label{conclusion}

These string rewriting exercises provided valuable insight into the mathematical foundations of computation. The exercises demonstrated how:

\begin{itemize}
\item Simple rewrite rules can implement complex algorithms
\item Invariants provide powerful tools for proving correctness
\item Mathematical abstraction helps understand algorithm behavior
\item Formal systems can serve as models for computation
\end{itemize}

The experience of working through these puzzles has improved my ability to think formally about computational problems and to construct rigorous arguments about program behavior. These skills will be valuable as I continue to study computer science and work with different programming paradigms.

\begin{thebibliography}{99}
\bibitem[ARS]{ars} Franz Baader and Tobias Nipkow, \href{https://en.wikipedia.org/wiki/Abstract_rewriting_system}{Term Rewriting and All That}, Cambridge University Press, 1998.
\bibitem[Term]{term} Nachum Dershowitz and Jean-Pierre Jouannaud, \href{https://en.wikipedia.org/wiki/Term_rewriting}{Rewrite Systems}, Handbook of Theoretical Computer Science, 1990.
\end{thebibliography}

\end{document}