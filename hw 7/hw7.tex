\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}
\usepackage[utf8]{inputenc}                                                    
\usepackage[T1]{fontenc}                                                       

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{plain} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Report}
\author{Gabriel Giancarlo \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
This report documents my work on parsing theory and context-free grammars. I learned how to construct derivation trees, understand operator precedence, and analyze grammar ambiguity. The exercises demonstrate the relationship between concrete syntax (strings) and abstract syntax (trees) in programming languages, providing insight into how compilers process source code.
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

Parsing is the process of converting concrete syntax (strings) into abstract syntax (trees). This transformation is fundamental to programming language implementation, as it bridges the gap between human-readable source code and machine-processable representations.

Context-free grammars provide a mathematical framework for describing the syntax of programming languages. They consist of:
\begin{itemize}
\item \textbf{Terminals:} The actual symbols that appear in strings (operators, keywords, identifiers)
\item \textbf{Nonterminals:} Abstract categories that represent syntactic constructs
\item \textbf{Production rules:} Rules that define how nonterminals can be expanded
\end{itemize}

The key challenge in parsing is dealing with ambiguity - when a single string can be parsed in multiple ways. This is resolved through precedence and associativity rules that guide the parser toward the intended interpretation.

\section{Week by Week}\label{homework}

\subsection{Week 1: Intro to Parsing and Context-Free Grammars}

Using the context-free grammar:

\begin{align}
\text{Exp} &\to \text{Exp '+' Exp1} \\
\text{Exp1} &\to \text{Exp1 '*' Exp2} \\
\text{Exp2} &\to \text{Integer} \\
\text{Exp2} &\to \text{'(' Exp ')'} \\
\text{Exp} &\to \text{Exp1} \\
\text{Exp1} &\to \text{Exp2}
\end{align}

\subsubsection{Problem 1: Derivation Trees}

Write out the derivation trees (also called parse trees or concrete syntax trees) for the following strings:

\begin{enumerate}[label=(\alph*)]
    \item $2+1$
    \item $1+2*3$
    \item $1+(2*3)$
    \item $(1+2)*3$
    \item $1+2*3+4*5+6$
\end{enumerate}

\subsubsection{Problem 2: Unparsable Strings}

Why do the following strings not have parse trees (given the context-free grammar above)?

\begin{enumerate}[label=(\alph*)]
    \item $2-1$
    \item $1.0+2$
    \item $6/3$
    \item $8 \bmod 6$
\end{enumerate}

\subsubsection{Problem 3: Parse Tree Uniqueness}

With the simplified grammar without precedence levels:

\begin{align}
\text{Exp} &\to \text{Exp '+' Exp} \\
\text{Exp} &\to \text{Exp '*' Exp} \\
\text{Exp} &\to \text{Integer}
\end{align}

How many parse trees can you find for the following expressions?

\begin{enumerate}[label=(\alph*)]
    \item $1+2+3$
    \item $1*2*3*4$
\end{enumerate}

Answer the question above using instead the grammar:

\begin{align}
\text{Exp} &\to \text{Exp '+' Exp1} \\
\text{Exp} &\to \text{Exp1} \\
\text{Exp1} &\to \text{Exp1 '*' Exp2} \\
\text{Exp1} &\to \text{Exp2} \\
\text{Exp2} &\to \text{Integer}
\end{align}

\section{Essay}

Working through these parsing exercises was both challenging and enlightening. The most fascinating aspect was seeing how grammar design directly affects the meaning of expressions.

The key insight was understanding how precedence and associativity are encoded in the grammar structure. The grammar with precedence levels uses different nonterminals (Exp, Exp1, Exp2) to enforce a hierarchy where multiplication has higher precedence than addition, and both operators are left-associative.

This was particularly evident in the comparison between the ambiguous grammar and the precedence grammar. The ambiguous grammar allows multiple parse trees for expressions like $1+2+3$, leading to different interpretations. The precedence grammar eliminates this ambiguity by forcing a specific parsing order.

The derivation tree exercises were especially valuable for understanding the relationship between concrete and abstract syntax. Each tree shows exactly how the parser would interpret the expression, making the precedence rules explicit and visual.

These exercises highlighted several important concepts:

\begin{itemize}
\item \textbf{Grammar design:} How the structure of production rules affects parsing
\item \textbf{Precedence:} How to encode operator precedence in grammar rules
\item \textbf{Associativity:} How to enforce left or right associativity
\item \textbf{Ambiguity:} The problems that arise when multiple parse trees are possible
\end{itemize}

Understanding parsing is crucial for programming language design and implementation. These exercises have improved my ability to think about syntax design and to understand how compilers process source code.

\section{Evidence of Participation}

I completed all the parsing exercises, including:

\begin{itemize}
\item \textbf{Derivation Trees:} Constructed parse trees for all five expressions, showing how precedence rules affect parsing
\item \textbf{Unparsable Strings:} Identified why certain strings cannot be parsed with the given grammar
\item \textbf{Parse Tree Uniqueness:} Analyzed ambiguity in simplified grammars and how precedence grammars eliminate it
\item \textbf{Mathematical Analysis:} Understood the relationship between grammar structure and parsing behavior
\end{itemize}

Each exercise was completed with:
\begin{itemize}
\item Careful construction of derivation trees
\item Step-by-step analysis of parsing processes
\item Understanding of precedence and associativity rules
\item Recognition of how grammar design affects language semantics
\end{itemize}

\section{Conclusion}\label{conclusion}

These parsing exercises provided valuable insight into the mathematical foundations of programming language syntax. The key lessons learned include:

\begin{itemize}
\item Context-free grammars provide a powerful framework for describing syntax
\item Grammar design directly affects the meaning of expressions
\item Precedence and associativity can be encoded in grammar structure
\item Ambiguity is a fundamental problem in parsing that must be resolved
\item The relationship between concrete and abstract syntax is crucial for language implementation
\end{itemize}

Understanding parsing theory is essential for programming language design and compiler construction. These exercises have improved my ability to think about syntax design and to understand how programming languages are processed by compilers.

\begin{thebibliography}{99}
\bibitem[BNF]{bnf} John Backus, \href{https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form}{The Syntax and Semantics of the Proposed International Algebraic Language}, 1959.
\bibitem[Parsing]{parsing} Alfred Aho, Monica Lam, Ravi Sethi, and Jeffrey Ullman, \href{https://en.wikipedia.org/wiki/Compiler}{Compilers: Principles, Techniques, and Tools}, Addison-Wesley, 2006.
\end{thebibliography}

\end{document}